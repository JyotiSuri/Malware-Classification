import java.io.*;
import java.util.*;


public class Preprocessor{
	private LinkedHashMap<String, Character> opcodeSymbolMap;
	private LinkedHashMap<Character, String> symbolOpcodeMap;
	
	public Preprocessor(){
		opcodeSymbolMap = new LinkedHashMap<>();
		symbolOpcodeMap = new LinkedHashMap<>();
	}

	public LinkedHashMap<String, Character> getOpcodeSymbolMap(){
		return opcodeSymbolMap;
	}
	
	/**
	 * Counts the number of files per family
	 */
	public void countSamplePerFamily(){
		try{
			File countFile = new File("./counts.txt");
			FileWriter fw = new FileWriter(countFile);
			PrintWriter pw = new PrintWriter(fw);

			File folder = new File(GROUP_PATH);
			String[] familyFolders = folder.list();

			for (String familyFolder: familyFolders) {
				File subFolder = new File(GROUP_PATH+"/"+familyFolder);
				int length = subFolder.list().length;
				pw.println(familyFolder + ": " + length);
			}

			pw.close();
			fw.close();
		}
		catch(Exception e){
			System.out.println("Stress in counting samples per family: " + e.getMessage());
		}
	}

	public void countNGramsPerFamily(int n) {
		try {
			File folder = new File(GROUP_PATH);
			String[] subFolderNames = folder.list();

			for (String subFolderName: subFolderNames) {
				if (!subFolderName.equals("Unknown")) {
					File subFolder = new File(GROUP_PATH + "/" + subFolderName);
					Map<String, Integer> frequencyMap = new HashMap<>();
					String[] fileNames = subFolder.list();

					for (String fileName: fileNames) {
						List<String> nGramsList = new ArrayList<>(n);
						File file = new File(GROUP_PATH + "/" + subFolderName + "/" + fileName);
						FileReader fr = new FileReader(file);
						BufferedReader br = new BufferedReader(fr);
						String line = "";

						while ((line = br.readLine()) != null) {
							nGramsList.add(0, line);
							if (nGramsList.size() == n) {
								String key = "";

								for (int i = n-1; i >= 0; i--)
									key += nGramsList.get(i);

								if (!frequencyMap.containsKey(key))
									frequencyMap.put(key, 0);
								int oldFreq = frequencyMap.get(key);
								frequencyMap.put(key, ++oldFreq);

								nGramsList.remove(n-1);
							}
						}

						br.close();
						fr.close();
					}


					Map<String, Integer> maxFreqMap = new LinkedHashMap<>();
					opcodeSymbolMap = new LinkedHashMap<>();
					symbolOpcodeMap = new LinkedHashMap<>();

					for (int i = 0; i < MAX_INSTRUCTIONS_TO_EXTRACT; i++) {
						int maxFreq = Integer.MIN_VALUE;
						String keyWithMaxFreq = "";

						for (String key: frequencyMap.keySet()) {
							if (frequencyMap.get(key) >= maxFreq) {
								keyWithMaxFreq = key;
								maxFreq = frequencyMap.get(key);
							}
						}

						maxFreqMap.put(keyWithMaxFreq, maxFreq);
						frequencyMap.remove(keyWithMaxFreq);

						if (i != MAX_INSTRUCTIONS_TO_EXTRACT - 1) {
							opcodeSymbolMap.put(keyWithMaxFreq, (char)(65 + i));
							symbolOpcodeMap.put((char)(65 + i), keyWithMaxFreq);
						}
						else {
							opcodeSymbolMap.put("default", (char)(65 + i));
							symbolOpcodeMap.put((char)(65 + i), "default");
						}
					}

					//Frequency 
					File frequencyFile = new File(GROUP_PATH + "/" + subFolderName + "/"  + "/frequency.txt");
					FileWriter fw = new FileWriter(frequencyFile);
					PrintWriter pw = new PrintWriter(fw);

					for (String key: frequencyMap.keySet()) 
						pw.println(key + ": " + frequencyMap.get(key));

					pw.close();
					fw.close();

					//max frequency
					File maxFrequencyFile = new File(GROUP_PATH + "/" + subFolderName + "/"  + "/maxFrequency.txt");
					fw = new FileWriter(maxFrequencyFile);
					pw = new PrintWriter(fw);

					for (String key: maxFreqMap.keySet())
						pw.println(key + ": " + maxFreqMap.get(key));

					pw.close();
					fw.close();

					//opcode symbol mapping
					File opcodeSymbolFile = new File(GROUP_PATH + "/" + subFolderName + "/"  + "/opcodeSymbolMap.txt");
					fw = new FileWriter(opcodeSymbolFile);
					pw = new PrintWriter(fw);

					for (String key: opcodeSymbolMap.keySet())
						pw.println(key + ": " + opcodeSymbolMap.get(key));

					pw.close();
					fw.close();
					
					File symbolOpcodeFile = new File(GROUP_PATH + "/" + subFolderName + "/"  + "/symbolOpcodeMap.txt");
					fw = new FileWriter(symbolOpcodeFile);
					pw = new PrintWriter(fw);
					
					for (Character key: symbolOpcodeMap.keySet())
						pw.println(key + ": " + symbolOpcodeMap.get(key));
					
					pw.close();
					fw.close();

					File subFolderProcessed = new File(GROUP_PATH + "/" + subFolderName + "/" + "processed");
					subFolderProcessed.mkdir();

					for (String fileName: fileNames) {
						List<String> nGramsList = new ArrayList<>(n);
						File inputFile = new File(GROUP_PATH + "/" + subFolderName + "/" + fileName);
						FileReader fr = new FileReader(inputFile);
						BufferedReader br = new BufferedReader(fr);

						File outputFile = new File(GROUP_PATH + "/" + subFolderName + "/" + "processed" + "/" + fileName);
						outputFile.createNewFile();
						fw = new FileWriter(outputFile);
						pw = new PrintWriter(fw);

						String line = "";

						while ((line = br.readLine()) != null) {
							nGramsList.add(0, line);
							if (nGramsList.size() == n) {
								String key = "";

								for (int i = n-1; i >= 0; i--)
									key += nGramsList.get(i);

								if (opcodeSymbolMap.containsKey(key))
									pw.println(opcodeSymbolMap.get(key));
								else 
									pw.println(opcodeSymbolMap.get("default"));

								nGramsList.remove(n-1);
							}
						}

						pw.close();
						fw.close();

						br.close();
						fr.close();
					}
				}
			}
		}
		catch(Exception e) {
			System.out.println("Stress in counting opcodes per family: " + e.getMessage());
		}
	}


	/**
	 * Creates a dictionary of opcodes and their frequency for a family. 
	 */
	public void countOpcodePerFamily() {
		try {
			File folder = new File(GROUP_PATH);
			String[] subFolderNames = folder.list();

			for (String subFolderName: subFolderNames) {
				if (!subFolderName.equals("Unknown")) {
					File subFolder = new File(GROUP_PATH + "/" + subFolderName);
					Map<String, Integer> frequencyMap = new HashMap<>();
					String[] fileNames = subFolder.list();

					for (String fileName: fileNames) {
						File file = new File(GROUP_PATH + "/" + subFolderName + "/" + fileName);
						FileReader fr = new FileReader(file);
						BufferedReader br = new BufferedReader(fr);
						String line = "";

						while ((line = br.readLine()) != null) {
							if (!frequencyMap.containsKey(line))
								frequencyMap.put(line, 0);

							int oldFreq = frequencyMap.get(line);
							frequencyMap.put(line,  ++oldFreq);
						}

						br.close();
						fr.close();
					}


					Map<String, Integer> maxFreqMap = new LinkedHashMap<>();
					opcodeSymbolMap = new LinkedHashMap<>();
					symbolOpcodeMap = new LinkedHashMap<>();

					for (int i = 0; i < MAX_INSTRUCTIONS_TO_EXTRACT; i++) {
						int maxFreq = Integer.MIN_VALUE;
						String keyWithMaxFreq = "";

						for (String key: frequencyMap.keySet()) {
							if (frequencyMap.get(key) >= maxFreq) {
								keyWithMaxFreq = key;
								maxFreq = frequencyMap.get(key);
							}
						}

						maxFreqMap.put(keyWithMaxFreq, maxFreq);
						frequencyMap.remove(keyWithMaxFreq);

						if (i != MAX_INSTRUCTIONS_TO_EXTRACT - 1) {
							opcodeSymbolMap.put(keyWithMaxFreq, (char)(65 + i));
							symbolOpcodeMap.put((char)(65 + i), keyWithMaxFreq);
						}
						else {
							opcodeSymbolMap.put("default", (char)(65 + i));
							symbolOpcodeMap.put((char)(65 + i), "default");
						}
					}

					//Frequency 
					File frequencyFile = new File(GROUP_PATH + "/" + subFolderName + "/"  + "/frequency.txt");
					FileWriter fw = new FileWriter(frequencyFile);
					PrintWriter pw = new PrintWriter(fw);

					for (String key: frequencyMap.keySet()) 
						pw.println(key + ": " + frequencyMap.get(key));

					pw.close();
					fw.close();

					//max frequency
					File maxFrequencyFile = new File(GROUP_PATH + "/" + subFolderName + "/"  + "/maxFrequency.txt");
					fw = new FileWriter(maxFrequencyFile);
					pw = new PrintWriter(fw);

					for (String key: maxFreqMap.keySet())
						pw.println(key + ": " + maxFreqMap.get(key));

					pw.close();
					fw.close();

					//opcode symbol mapping
					File opcodeSymbolFile = new File(GROUP_PATH + "/" + subFolderName + "/"  + "/opcodeSymbolMap.txt");
					fw = new FileWriter(opcodeSymbolFile);
					pw = new PrintWriter(fw);

					for (String key: opcodeSymbolMap.keySet())
						pw.println(key + ": " + opcodeSymbolMap.get(key));

					pw.close();
					fw.close();

					
					//symbol opcode mapping
					File symbolOpcodeFile = new File(GROUP_PATH + "/" + subFolderName + "/"  + "/symbolOpcodeMap.txt");
					fw = new FileWriter(symbolOpcodeFile);
					pw = new PrintWriter(fw);
					
					for (Character key: symbolOpcodeMap.keySet())
						pw.println(key + ": " + symbolOpcodeMap.get(key));
					
					pw.close();
					fw.close();
					
					File subFolderProcessed = new File(GROUP_PATH + "/" + subFolderName + "/" + "processed");
					subFolderProcessed.mkdir();

					for (String fileName: fileNames) {
						File inputFile = new File(GROUP_PATH + "/" + subFolderName + "/" + fileName);
						FileReader fr = new FileReader(inputFile);
						BufferedReader br = new BufferedReader(fr);

						File outputFile = new File(GROUP_PATH + "/" + subFolderName + "/" + "processed" + "/" + fileName);
						outputFile.createNewFile();
						fw = new FileWriter(outputFile);
						pw = new PrintWriter(fw);

						String line = "";

						while ((line = br.readLine()) != null) {
							if (opcodeSymbolMap.containsKey(line))
								pw.println(opcodeSymbolMap.get(line));
							else 
								pw.println(opcodeSymbolMap.get("default"));
						}

						pw.close();
						fw.close();

						br.close();
						fr.close();
					}
				}
			}
		}
		catch(Exception e) {
			System.out.println("Stress in counting opcodes per family: " + e.getMessage());
		}
	}

	/**
	 * Removes the opcode frequency files for each family. 
	 */
	public void removeFrequencyFiles() {
		File folder = new File(GROUP_PATH);
		String[] subFolderNames = folder.list();

		for (String subFolderName: subFolderNames) {
			File subFolder = new File(GROUP_PATH + "/" + subFolderName);
			String[] fileNames = subFolder.list();

			for (String fileName: fileNames) {
				if (fileName.equals("frequency.txt")){
					File f = new File(GROUP_PATH + "/" + subFolderName + "/frequency.txt");
					f.delete();
				}
				if (fileName.equals("maxFrequency.txt")) {
					File f = new File(GROUP_PATH + "/" + subFolderName + "/maxFrequency.txt");
					f.delete();
				}
				if (fileName.equals("opcodeSymbolMap.txt")) {
					File f = new File(GROUP_PATH + "/" + subFolderName + "/opcodeSymbolMap.txt");
					f.delete();
				}
				if (fileName.equals("symbolOpcodeMap.txt")) {
					File f = new File(GROUP_PATH + "/" + subFolderName + "/symbolOpcodeMap.txt");
					f.delete();
				}
			}
		}
	}

	public void removeProcessedFiles() {
		File folder = new File(GROUP_PATH);
		String[] subFolderNames = folder.list();

		for (String subFolderName: subFolderNames) {
			File processedFolder = new File(GROUP_PATH + "/" + subFolderName + "/processed");

			if (processedFolder.exists()) {
				if (processedFolder.isDirectory()) {
					String[] processedFileNames = processedFolder.list();

					for (String processedFileName: processedFileNames) {
						File file = new File(GROUP_PATH + "/" + subFolderName + "/processed" + "/" + processedFileName);
						file.delete();
					}

					processedFolder.delete();
				}
			}

		}
	}

	public void deleteCreatedStuff() {
		removeFrequencyFiles();
		removeProcessedFiles();
	}
	

	private static final String GROUP_PATH = "./dataset";
	private static final int MAX_INSTRUCTIONS_TO_EXTRACT = 30;

	public static void main(String[] args){
		Preprocessor preprocessor = new Preprocessor();
		preprocessor.deleteCreatedStuff();
		preprocessor.countNGramsPerFamily(4);
	}
}
