import java.io.*;
import java.util.*;


//@authors Jyoti Suri, Tirth Patel, Akshat Bansal

public class Model {
	public static void main(String[] args){
		int N = 2;
		int M = 30;

		Model model = new Model(N, M);

		for (int i = 0; i < 200; i++)
			model.recompute();

		System.out.println("TESTING NOW...");
		model.runTests("./dataset/smarthdd");
	}




	public Model(int N, int M) {
		this.N = N;
		this.M = M;


		pi = new double[N];
		A = new double[N][N];
		B = new double[N][M];	

		Random rand = new Random();

		double sum = 0;

		for (int i = 0; i < N - 1; i++) {
			pi[i] = 1.0/N + rand.nextDouble()/10;
			sum += pi[i];
		}
		pi[N-1] = 1 - sum;

		for (int i = 0; i < N; i++) {
			A[i] = new double[N];
			for (int j = 0; j < N; j++) {
				double offset = rand.nextDouble()/10;
				offset -= rand.nextDouble()/10;
				A[i][j] = 1.0/N + offset;
			}
		}

		for (int n = 0; n < N; n++) {
			B[n] = new double[M];
			for (int m = 0; m < M; m++) {
				double offset = rand.nextDouble()/1000;
				offset -= (rand.nextDouble()/1000);
				B[n][m] = 1.0/M + offset;
			}
		}

		opcodeSymbolMap = new LinkedHashMap<>();
		this.observation = getObservationSequence();
		T = observation.length;
		oldLogProb = Double.MIN_VALUE;

		alpha = new double[T][N];
		c = new double[T];
		gamma = new double[T][N];
		digamma = new double[T][N][M];
		beta = new double[T][N];


	}

	public double score(int[] test) {
		T  = test.length;
		alphaPass(test);

		//printEverything();


		return Math.max(alpha[T-1][0], alpha[T-1][1]);
	}

	public void alphaPass(int[] observation) {
		T = observation.length;
		alpha = new double[T][N];


		// compute alpha[0][i]
		c[0] = 0;
		for (int i = 0; i < N; i++) {
			alpha[0][i] = (pi[i]) * (B[i][observation[0]]);
			c[0] = c[0] + alpha[0][i];
		}

		// scale alpha[0][i]
		c[0] = 1 / c[0];
		for (int i = 0; i < N; i++)
			alpha[0][i] = (alpha[0][i]) * c[0];


		// compute alpha[t][i]
		for (int t = 1; t < T; t++) {
			c[t] = 0;
			for (int i = 0; i < N; i++) {
				alpha[t][i] = 0;
				for (int j = 0; j < N; j++)
					alpha[t][i] += (alpha[t - 1][j]) * (A[j][i]);

				alpha[t][i] = (alpha[t][i]) * (B[i][observation[t]]);
				c[t] = c[t] + alpha[t][i];
			}

			// scale alpha[t][i]
			c[t] = 1 / c[t];
			for (int i = 0; i < N; i++)
				alpha[t][i] = (c[t]) * (alpha[t][i]);
		}
	}

	public void betaPass() {

		// Let beta[T-1][i] = 1, scaled by c[T-1]
		for (int i = 0; i < N; i++)
			beta[T - 1][i] = c[T - 1];

		// beta pass
		for (int t = T - 2; t >= 0; t--) {
			for (int i = 0; i < N; i++) {
				beta[t][i] = 0;
				for (int j = 0; j < N; j++)
					beta[t][i] += (A[i][j]) * (B[j][observation[t + 1]]) * (beta[t + 1][j]);

				// scale beta[t][i] with same scale factor as alpha[t][i]
				beta[t][i] = (c[t]) * (beta[t][i]);
			}
		}
	}

	public void gammaDigammaPass() {
		for (int t = 0; t < T - 1; t++) {
			for (int i = 0; i < N; i++) {
				gamma[t][i] = 0;
				for (int j = 0; j < N; j++) {
					digamma[t][i][j] = (alpha[t][i]) * (A[i][j]) * (B[j][observation[t + 1]]) * (beta[t + 1][j]);
					gamma[t][i] += digamma[t][i][j];
				}
			}
		}

		// Special case for gamma[T-1][i] (as above, no need to normalize)
		for (int i = 0; i < N; i++)
			gamma[T - 1][i] = alpha[T - 1][i];
	}

	public void reestimate() {
		// re-estimate pi
		for (int i = 0; i < N; i++)
			pi[i] = gamma[0][i];

		// re-estimate A
		for (int i = 0; i < N; i++) {
			double denom = 0;
			for (int t = 0; t <= T - 2; t++)
				denom += gamma[t][i];

			for (int j = 0; j < N; j++) {
				double numer = 0;
				for (int t = 0; t <= T - 2; t++)
					numer += digamma[t][i][j];
				A[i][j] = numer / denom;
			}
		}

		// re-estimate B
		for (int i = 0; i < N; i++) {
			double denom = 0;
			for (int t = 0; t < T; t++)
				denom += gamma[t][i];
			for (int j = 0; j < M; j++) {
				double numer = 0;
				for (int t = 0; t < T; t++) 
					if (observation[t] == j)
						numer += gamma[t][i];
				B[i][j] = numer / denom;
			}

		}
	}

	public void logProbCalc() {
		logProb = 0;
		for (int i = 0; i <= T - 1; i++) 
			logProb = logProb + Math.log(c[i]);
		logProb = -logProb;
	}

	public void decision() {
		iters = iters + 1;
		if (iters < maxIters && logProb > oldLogProb) {
			oldLogProb = logProb;
			recompute();
		}
	}

	public void recompute() {
		alphaPass(observation);
		betaPass();
		gammaDigammaPass();
		reestimate();
		logProbCalc();
		printEverything();
		decision();
	}


	public int[] getObservationSequence(){
		int[] observationSequence = new int[OBSERVATION_SEQUENCE_LENGTH];
		int count = 0;

		try{
			File opcodeSymbolFile = new File(TRAINING_PATH + "/opcodeSymbolMap.txt");
			FileReader fr = new FileReader(opcodeSymbolFile);
			BufferedReader br = new BufferedReader(fr);

			String line = "";
			while ((line = br.readLine()) != null) {
				int colonNdx = line.indexOf(':');
				opcodeSymbolMap.put(line.substring(0, colonNdx), line.charAt(colonNdx + 2));
			}

			br.close();
			fr.close();


			File folder = new File(TRAINING_PATH + "/processed/training");

			String[] filenames = folder.list();

			for (String filename: filenames){
				File file = new File(TRAINING_PATH + "/processed/training/" + filename);
				fr = new FileReader(file);
				br = new BufferedReader(fr);


				line = "";

				while ((line = br.readLine()) != null){
					if (count >= OBSERVATION_SEQUENCE_LENGTH) {
						br.close();
						fr.close();
						return observationSequence;
					}

					observationSequence[count++] = line.charAt(0) - 'A';
				}

				br.close();
				fr.close();
			}
		}

		catch(Exception e){
			System.out.println("Stress in getting data: " + e.getMessage());
		}

		return observationSequence;
	}

	public void runTests(String familyPath) {
		try {
			File testFolder = new File(familyPath + "/processed/test");
			Map<Character, String> symbolOpcodeMap = new HashMap<>();
			File symbolOpcodeFile = new File(familyPath + "/symbolOpcodeMap.txt");
			FileReader fr = new FileReader(symbolOpcodeFile);
			BufferedReader br = new BufferedReader(fr);

			String line = "";
			while ((line = br.readLine()) != null) {
				int colonNdx = line.indexOf(':');
				symbolOpcodeMap.put(line.charAt(0), line.substring(colonNdx + 2));
			}

			br.close();
			fr.close();

			String[] fileNames = testFolder.list();

			for (String fileName: fileNames) {
				ArrayList<Integer> testSequence = new ArrayList<>();

				File testFile = new File(familyPath + "/processed/test/" + fileName);
				fr = new FileReader(testFile);
				br = new BufferedReader(fr);

				line = "";

				while ((line = br.readLine()) != null) {
					String opcode = symbolOpcodeMap.get(line.charAt(0));
					char symbol = '^';

					if (opcodeSymbolMap.containsKey(opcode))
						symbol = opcodeSymbolMap.get(opcode);

					testSequence.add(symbol - 'A');
				}

				fr.close();
				br.close();

				int[] arr = new int[testSequence.size()];

				for (int i = 0; i < testSequence.size(); i++)
					arr[i] = testSequence.get(i);

				System.out.println(fileName+ ": " + score(arr));
			}

		}
		catch(Exception e) {
			System.out.println("Stress in running tests: " + e.getMessage());
		}
	}


	private void printEverything() {
		System.out.println("*****************");
		System.out.println(Arrays.deepToString(A));

		for (int i = 0; i < M; i++) {
			char c = (char) (i + 'A');
			System.out.print(c+": ");

			for (int j = 0; j < N; j++) 
				System.out.print(B[j][i] + " ");

			System.out.println();
		}

		System.out.println(Arrays.toString(pi));
		System.out.println("Score:" + logProb);
		System.out.println("*****************");
	}

	public int getMaxIterations() {
		return maxIters;
	}



	int maxIters = 100;// maximum number of re-estimation iterations
	int iters = 0;
	double logProb;
	double oldLogProb;

	double[][] A;
	double[][] B;
	double[] pi;
	double[] c; // scaling
	int[] observation; // observation sequence

	double[][] alpha;
	double[][] beta;
	double[][] gamma;
	double[][][] digamma;

	int M; // number of observation symbols
	int N; // number of states in the model
	int T; // length of observation sequence

	private static final String TRAINING_PATH = "./dataset/smarthdd";
	//private static final String MODEL_PATH = "./model";+
	private static final int OBSERVATION_SEQUENCE_LENGTH = 90000;

	private Map<String, Character> opcodeSymbolMap;
}
